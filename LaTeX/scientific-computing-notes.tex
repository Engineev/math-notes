\documentclass[12pt, a4paper]{article}
\usepackage{ctex}

\usepackage[margin=1in]{geometry}
\usepackage{
  color,
  clrscode,
  amssymb,
  ntheorem,
  amsmath,
  listings,
  fontspec,
  xcolor,
  supertabular,
  multirow,
  mathtools,
  mathrsfs
}
\definecolor{bgGray}{RGB}{36, 36, 36}
\usepackage[
  colorlinks,
  linkcolor=bgGray,
  anchorcolor=blue,
  citecolor=green
]{hyperref}
\newfontfamily\courier{Courier}

\theoremstyle{margin}
\theorembodyfont{\normalfont}
\newtheorem{thm}{定理}
\newtheorem{cor}[thm]{推论}
\newtheorem{pos}[thm]{命题}
\newtheorem{lemma}[thm]{引理}
\newtheorem{defi}[thm]{定义}
\newtheorem{std}[thm]{标准}
\newtheorem{imp}[thm]{实现}
\newtheorem{alg}[thm]{算法}
\newtheorem{exa}[thm]{例}
\newcommand{\st}{\text{s.t.}}
\newcommand{\hp}{^\prime}
\newcommand{\ms}{\mathscr}
\newcommand{\mn}{\mathnormal}
\newcommand{\tbf}{\textbf}
\newcommand{\mbf}{\mathbf}
\newcommand{\fl}{\mathnormal{fl}}
\newcommand{\f}{\mathnormal{f}}
\newcommand{\g}{\mathnormal{g}}
\newcommand{\R}{\mathbf{R}}
\newcommand{\Q}{\mathbf{Q}}
\newcommand{\JD}{\textbf{D}}
\newcommand{\rd}{\mathrm{d}}
\newcommand{\str}{^*}
\newcommand{\vep}{\varepsilon}
\newcommand{\lhs}{\text{L.H.S}}
\newcommand{\rhs}{\text{R.H.S}}
\newcommand{\con}{\text{Const}}
\newcommand{\oneton}{1,\,2,\,\dots,\,n}
\newcommand{\aoneton}{a_1a_2\dots a_n}
\newcommand{\xoneton}{x_1,\,x_2,\,\dots,\,x_n}
\newcommand\thmref[1]{定理\ref{#1}}
\newcommand\lemmaref[1]{引理\ref{#1}}
\newcommand\defref[1]{定义\ref{#1}}
\newcommand\equref[1]{(\ref{#1})}
\newcommand{\remark}{\paragraph{评注}}
\newcommand{\example}{\paragraph{例}}
\newcommand{\proof}{\paragraph{证明}}

\title{科学计算 笔记}
\author{任云玮}
\date{}

\begin{document}
\lstset{numbers=left,
  basicstyle=\scriptsize\courier,
  numberstyle=\tiny\courier\color{red!89!green!36!blue!36},
  language=C++,
  breaklines=true,
  keywordstyle=\color{blue!70},commentstyle=\color{red!50!green!50!blue!50},
  morekeywords={},
  stringstyle=\color{purple},
  frame=shadowbox,
  rulesepcolor=\color{red!20!green!20!blue!20}
}
\maketitle
\tableofcontents
\newpage

\section{绪论}

\subsection{计算机数值计算基本原理}

\subsubsection{实数的存贮方法}
  \begin{defi}[二进制浮点数系]\footnote{floating Number System}
    实数在计算机内部为\tbf{近似存贮}，采用二进制浮点数系
    \[
      F(2,n,L,U)=\{\pm0.\aoneton\times10^m\}\cup\{0\}
    \]
    其中$a_1=1$，$a_i\in\{0,\,1\}$. 指数$m$满足$L\le m\le U$.
    称$n$为其字长，$2$表示采用二进制。
  \end{defi}

  \begin{std}[IEEE]
    $\,$
    \begin{enumerate}
      \item 单精度: $t=24,L=-126,U=127$
      \item 双精度: $t=53,L=-1022,U=1023$
      \item Underflow Limit: $UFL=0.1\times2^L$.
      若$0<x<UFL$，则$\\fl(x)=0$.
      \item Overflow Limit: $OFL=0.11\dots1*2^U$.
      若$x>OFL$，则$\fl(x)=\infty$.
      \item 舍入: 若$UFL\le x\le OFL$，则$\fl(x)$为舍入所得浮点数。
      舍入规则如下：设$x=0.\aoneton\dots\times2^m$. 若$a_{n+1}=1$，
      则$d_t+1$并舍弃其后项；否则直接舍弃其后项。
    \end{enumerate}
  \end{std}

  \begin{defi}[机器精度]
    下仅考虑舍去的情况。
    \[\begin{split}
    x-\fl(x) &= 2^m \times 0.0\dots0a_{n+2}\dots \\
    &=2^m \times [2^{-(t+2)} + 2^{-(t+3)} + \cdots] \\
    &=2^m\times2^{-(t+1)}
    \end{split}\]
    其相对误差满足
    \[
      \frac{x-\fl(x)}{x} < \frac{x-\fl(x)}{0.5\times2^m}=2^{-t}
    \]
    记为$\varepsilon$，称之为机器精度。
  \end{defi}

  \begin{pos}
    \[
      \fl(x)=x(1+\delta),\,\text{其中}\,|\delta|\le\varepsilon
    \]
  \end{pos}

\subsubsection{实数的基本运算原理}
  加法$+$硬件实现$\Rightarrow$四则运算。

  \begin{imp}[$x+y$]
    设$x,\,y$为浮点数，则$x+y$的实现方式如下：
    \begin{enumerate}
      \item 对阶：将指数$m$化为两者中较大者；
      \item 尾数相加；
      \item 舍入；
      \item 溢出分析等……
      \item 结果输出。
    \end{enumerate}
  \end{imp}
  \remark
    由$\fl(x)+\fl(y)=x(1+\delta_x)+y(1+\delta_y)$可知，当一个
    大数与一个小数相加时，小数有可能被忽略，所以应当避免大数小数间的相加。

\newpage
\subsection{误差的来源与估计}

\subsubsection{误差的来源}
 \begin{enumerate}
  \item 模型问题。例：近似地球为球体来计算。
  \item 测量误差。例：测量地球半径时的误差。
  \item 方法误差（截断误差）。
  例：对于$y=\f(x)$，求$\f(x^*)$时使用Taylor展开。
  \item 舍入误差（rounding-off）。例：计算机计算时的误差。
 \end{enumerate}

\subsubsection{误差与有效数字}
  \begin{defi}[绝对误差]
    设$x$为给定实数，$x^*$为其近似值。定义绝对误差为
    \[
      e(x^*) = x^* - x.
    \]
    称$\varepsilon^*$为其误差上界，若
    \[
      |e(x^*)| \le \varepsilon^*
    \]
  \end{defi}

  \begin{defi}[相对误差]
    对于同上的$x$和$x^*$，定义其相对误差
    \[
      e_r(x^*)=\frac{x^* - x}{x}
    \]
    称$\varepsilon_r^*$为其相对误差界，若
    \[
      |e_r(x^*)|\le\varepsilon_r^*
    \]
  \end{defi}
  \remark
    在实际应用中，$x$通常是未知的，所以会采用
    \[
      \bar{e}_r(x^*)=\frac{x^*-x}{x^*}
    \]
    来代替相对误差。对于分子，使用绝对误差界来替代，有如下不等式
    \[
      |\bar{e}_r(x^*)| \le \frac{\varepsilon^*}{|x^*|}.
    \]
    这两种相对误差界间的差别，当$\varepsilon^*\ll 1$时，满足
    \[
      |e_r-\bar{e}_r|=O((\varepsilon_r^*)^2)
    \]

  \begin{defi}[有效数字]
    设$x\in R$，$x^*=0.a_1a_2\cdots a_k\times 10^m$为其近似值。
    称$x^*$相对于$x$有$n\,(n\le k)$位有效数字，
    若$n$是满足下式的$n$的最大值。
    \[
      |x^* - x| \le \frac{1}{2} \times 10^{m - n}
    \]
  \end{defi}
  \remark
    在实践中，一般可以采用更加简便的方法，对于归一化以后的$x^*$，
    在尾数部分有$n$位，则称其有$n$位有效数字。注意，此方法对于
    错误的舍入结果是不适用的，对于错误的情况，需要再减去一位有效
    数字。

  \begin{thm}[误差与有效数字]
    若$x=0.\aoneton\times10^m$有$n$位有效数字，则
    \[
      \vep^*_r \le
      \frac{1}{2a_1}\times10^{1-n}.
    \]
    反之，若
    \[
      \vep^*_r \le
      \frac{1}{2(1+a_1)}\times 10^{1-n},
    \]
    则$x^*$至少有$n$位有效数字。
  \end{thm}
  \proof
    对于前者，只需利用有效数字的定义，以及利用$x\ge 0.a_1$
    （仅考虑$a_1\ne0$的情况）。对于后者，证明是类似的。

\subsubsection{数值运算的误差估计}
  以下内容都假设运算无误差。
  \begin{thm}[四则运算误差估计]
    $\,$
    \begin{enumerate}
      \item 加/减法: $\varepsilon(x\str\pm y\str)
      \le \varepsilon_x\str + \varepsilon_y\str$
      \item 乘法: $\vep(x\str y\str) \le
      |x\str|\vep\str_y + |y\str|\vep\str_x$
      \item 除法: $\vep(\dfrac{x\str}{y\str}) \le
      \dfrac{|x\str|\vep\str_y + |y\str|\vep\str_x}{|y\str|^2}$
    \end{enumerate}
  \end{thm}
  \proof
    考虑加法的误差估计。对于$x$，$y$及其近似值$x^*$，$y^*$，
    计算$x\str\pm y\str$和$x\pm y$间的误差。
    \[\begin{split}
        & |x\str\pm y\str - ( x \pm y)|
        \le |x\str - x| + |y\str - y|
        \le \varepsilon_x\str + \varepsilon_y\str \\
        \Rightarrow\quad& \varepsilon(x\str\pm y\str)
        \le \varepsilon_x\str + \varepsilon_y\str
    \end{split}\]
    对于其他的运算，证明是类似的。（证明中可用$+1-1$技巧）

  \begin{thm}[运算的误差估计]
    设$A = \f(\tbf{x}) = \f(\xoneton)$，$\tbf{x}\str$是
    $\tbf{x}$的估计值。利用带Peano余项的Taylor展开，可知
    $A$的绝对误差满足
    \[\begin{split}
      e(A\str) &= \f(\tbf{x}\str) - \f(\tbf{x}) \\
      &= \sum_{p=1}^q\rd^k\f(\tbf{x}\str) + o(||x\str-x||^q) \\
      &\text{取q=1，则} \\
      &= \sum_{k=1}^n\partial_k\f(\tbf{x}\str)(x\str-x) + o(||x\str-x||)
    \end{split}\]
    利用上式，可知
    \[\begin{split}
      &\vep(A\str) \approx
      \sum_{k=1}^n
      \left|\partial_k\f(\tbf{x}\str)\right|\vep(x\str)\\
      &\vep_r(A\str) = \frac{\vep(A\str)}{|A\str|}
    \end{split}\]
  \end{thm}
  \remark
    对于定义在$\R$上的函数，即为
    \[
      \vep(\f(x^*)) \approx |\f\hp(x^*)|\vep(x^*)
    \]

\subsubsection{数字求和的舍入误差分析}
  \begin{pos}
    $n$个浮点数相加，若将它们从小到大排列后相加，则可以减小
    舍入误差。
  \end{pos}
  \proof
    考虑浮点数的求和$S_n=\sum_i^n a_i$，在计算机中的过程表现为
    \[\begin{split}
      & S_2^* = \fl(a_1+a_2)=(a_1+a_2)(1+\vep_2),\quad|\vep_2|\le\vep=2^{-t}\\
      & \cdots\cdots\\
      & S_n^* = \fl(S_{n-1}^*+a_n)(1+\vep_n),\quad|\vep_n|\le\vep
    \end{split}\]
    对于$S_n\str$的误差，若定义$\vep_1=0$，则
    \[
      S_n\str=\sum_{k=1}^n a_k\prod_{p=k}^n(1+\vep_p)
    \]
    对误差进行估计，舍去高阶无穷小，有
    \[
      \prod_{i=k}^n(1+\vep_k)\approx1+\sum_{i=k}^n\vep_k
    \]
    综合上两式，有
    \[\begin{split}
      S_n\str & \approx\sum_{k=1}^na_k(1+\sum_{p=k}^n\vep_p)\\
      & = S_n + \sum_{k=1}^na_k\sum_{p=k}^n\vep_p
    \end{split}\]
    进行移项，并取绝对值，再利用三角不等式，以及$|\vep_i|\le\vep$，得
    \[
      \left|S_n\str-S_n\right|
      \le \sum_{k=1}^n|a_k|\sum_{p=k}^n|\vep_p|
      \le \vep\sum_{k=1}^n|a_k|(n-k+1)
    \]
    其中$n-k+1$关于$k$单调减少，所以根据排序不等式
    [\lemmaref{lemma: 排序不等式}]，即可知命题成立。$\blacksquare$

\newpage
\subsection{避免算法失效的基本原则}
  \begin{thm}[原则]
    $\,$
    \begin{enumerate}
      \item 避免两数相除／相减，否则会严重损失有效数字。
      \item 避免两相近数相减。
      \item 避免绝对值很小的数做除数。
      \item 避免大数与小数相加；
      \item 简化计算步骤。
    \end{enumerate}
  \end{thm}


  \begin{alg}[高效计算$e^A$]
    高效计算$e^A$，其中$A\in\R^{n\times n}$。首先有
    \[
      e^A = e^{(A/2^n)2^n} = B^{2^n}
    \]
    只需要得到$B$，即可以利用倍乘的方法快速得到$B^{2^n}$。
    下对于$B$进行估计。当$x\to0$时，$e^x$有Taylor展开
    \[
      e^x = 1 + x + \cdots + \frac{x^n}{n!} + \cdots
    \]
    而取足够大的$n$，即可以使得$A/2^n\approx0$，则可以对它
    展开得
    \[
      B \approx I + C + \frac{1}{2}C^2,\,\text{其中}
      C = A/2^n
    \]
    而对于倍乘，考虑$B^2$，展开平方得
    \[
      B^2 \approx I + 2(C+\frac{1}{2}C^2) + (C+\frac{1}{2}C^2)^2
    \]
    从右至左相加即可。
  \end{alg}

  \begin{alg}[秦九韶，多项式估值]
    设有多项式\equref{equ: 多项式}，计算$p(z), z\in\R$的值。
    \begin{equation}
      \label{equ: 多项式}
      p(x) = a_0x^n + a_1x^{n-1} + \cdots + a_{n-1}x + a_n
    \end{equation}
    定义$b_n$满足
    \[
      b_0 = a_0, \quad b_k = a_k + b_{k-1}z
    \]
    则$b_n$即为所要求的值。并且成立
    \[
      p^{\prime}(z) = \sum_{k=0}^{n-1}b_kz^{n-1-k}
    \]
  \end{alg}
  \proof
    用$x-z$去除$p(x)$，记所得余数为$b_n(x)$，即
    \[
      p(x) = (x-z)q(x) + b_n(x),
    \]
    代入$x=z$，则左侧第一项为$0$，可知$p(z) = b_n(z)$。
    将两边的式子展开，利用对应系数相等，即可得算法中$b_n$
    的递推式。

  \begin{thm}[外推法]
    设$x_0$，$x_1$是$x$的两个估计值，且$x_1$相较于$x_0$更
    接近$x$，则可以通过恰当的权值$\omega$，使得它们的加权平均
    \[
      \bar{x} = x_1 + \omega(x_1-x_0)
    \]
    更加接近精确值$x$。
  \end{thm}

  \begin{alg}[$\pi$的估计]
    考虑单位圆，其面积为$\pi$，设$\pi_n$为单位圆的内接正$2n$边形
    的面积，以及
    \[
      \widetilde{\pi}_n = \frac{1}{3}(4\pi_{2n}-\pi_n)
    \]
    则$\pi_n$与$\widetilde{\pi}_n$与$\pi$的误差满足
    \[
      |\pi_n - \pi| = O(\frac{1}{n^2}), \quad
      |\widetilde{\pi}_n - \pi| = O(\frac{1}{n^4})
    \]
  \end{alg}
  \proof
    对于$\pi_n$.
    \[
      \pi_n=n\sin\frac{\pi}{n} =
      \pi - \frac{\pi^3}{3!}\frac{1}{n^2} +
      \frac{\pi^5}{5!}\frac{1}{n^4} - \cdots
      \,\Rightarrow \, |\pi_n - \pi| = O(\frac{1}{n^2})
    \]
    对于$\widetilde{\pi}_n$.
    \[\begin{split}
      \widetilde{\pi}_n & = \pi_{2n} + k(\pi_{2n} - \pi_n)
      = (1+k)\pi_{2n} - k\pi_n \\
      & = (1+k)(\pi - \frac{\pi^3}{3!}\frac{1}{4n^2} + \cdots)
      - k(\pi - \frac{\pi^3}{3!}\frac{1}{n^2} + \cdots) \\
      & = \pi - (\frac{k+1}{4} - k)\frac{\pi^3}{3!}\frac{1}{n^2}
      + O(\frac{1}{n^4})
    \end{split}\]
    为使式子的第二项为零，取$k=\frac{1}{3}$，则成立
    \[
      |\widetilde{\pi}_n - \pi| = O(\frac{1}{n^4})
      \quad\blacksquare
    \]
  \remark
    在实际中，$\pi_n$也是没有办法直接计算而得的，但是对于$n=3$，
    即$6$边形的情况，可以知道$\pi_3=3\sqrt{3}/2$。同时有递推
    公式
    \[
      \pi_{2n} = \sqrt{2n(n-\sqrt{n^2-\pi^2_n})},
    \]
    而开平方可以通过迭代的方式实现，从而即计算得到足够精确的
    $\pi_{2n}$和$\pi_n$。

\newpage
\section{函数的多项式插值与逼近}
\subsection{问题的提出}
  \begin{defi}[插值]
    \label{defi: 插值}
    设函数$y = \f(x)$在$[a, b]$上有定义，且已知在点
    $a\le x_0 < x_1 < \cdots < x_n \le b$处的函数值
    $y_i = \f(x_i)$，若存在一简单函数$P(x)$，成立
    \[
      P(x_i) = y_i,
    \]
    则称$P(x)$为$\f(x)$的插值函数，点$x_1,\,x_2,\,\dots,\,x_n$
    称为插值节点，$[a, b]$称为插值区间，求$P(x)$的方法被称为插值法。\par
    若$P(x) \in P_n$为次数不超过$n$的多项式，则称为多项式
  \end{defi}

  \iffalse
    给定一个函数$y = y(x)$在$[a, b]$中的点$x_0<\cdots<x_n$相应的函数值
    $y(x_i)$，设法重构函数$y = y(x)$。\footnote{从系统论的观点出发，
    即：已知映射$K$的一系列输入输出对，如何重构该映射$K$。}\par
    一般情况下解不唯一。所以设$y = y(x)$位于某一函数内，此时可能存在唯一解。
    例如，设$y(x)\in P_n$，则只需知道$n+1$个点的函数值，即可有唯一解。
      或者设输出$y_i$有测量误差。
      \[
      \widetilde{y}_i = \f(x_i) + \vep_i
      \]
      其中$\vep_i$为误差。
      \[
      y = \f(x) + \vep
      \]
      其中$\vep$正态分布。根据极大似然估计，等价于最小二乘解，
      （输出最小二乘法）
      \[
      \min_{y\in\pi} \sum_{i=0}^n|y_i - y(x_i)|^2
      \]
      其中$\pi$为某一个函数，有两种情况，
      \begin{enumerate}
      \item $\pi$由物理或化学规律确定；（基于机理建模）
      \item $\pi$由数据决定。（基于数据建模）
      \end{enumerate}
      （求关于权重和阈值的优化问题）；（非线性最小二乘解）。

    \paragraph{系统论的观点}
  \fi

\subsection{多项式插值}
  \begin{thm}[唯一性]
    给定满足\defref{defi: 插值}的$n+1$个点上的函数值，则
    次数不超过$n$的插值多项式$P_n(x)$存在且唯一。
  \end{thm}
  \proof
    利用待定系数法，设多项式的系数为$a_0,\,\dots\,a_n$，则
    有线性方程组
    \[
      \left\{
      \begin{gathered}
          a_0 + a_1x_0 + \cdots + a_nx_0^n = y_0,\\
          a_0 + a_1x_1 + \cdots + a_nx_1^n = y_1,\\
          \cdots\cdots \\
          a_0 + a_1x_n + \cdots + a_nx_n^n = y_n,\\
      \end{gathered}
      \right.
    \]
    其系数矩阵为Vandermonde矩阵
    \[
      A =
      \begin{pmatrix}
        1 & x_0 & \cdots & x_0^n \\
        1 & x_1 & \cdots & x_1^n \\
        \vdots & \vdots & & \vdots \\
        1 & x_n & \cdots & x_n^n \\
      \end{pmatrix}
    \]
    根据\defref{defi: 插值}中对于$x_i$的要求，矩阵行列式成立
    \[
      \det A = \prod_{i,j=0,\,i>j}^n (x_i - x_j) \ne 0.
    \]
    所以该方程组有唯一解。

  \begin{thm}[Lagrange插值法]
    \label{thm: Lagrange插值法}
    定义
    \[\begin{split}
      l_i(x) &= \frac{\prod_{j\ne i}(x - x_j)}{\prod_{j\ne i}(x_i - x_j)} \\
      (L_n\f)(x) &= \sum_{i=0}^ny_il_i(x),
    \end{split}\]
    则$L_n\f$即为$\f$的插值多项式。
  \end{thm}
  \proof
    考虑构造$l_i\in P_n$，满足条件$l_i(x_j) = \delta_{ij}$，这样
    $L_n\f=\sum y_il_i$满足要求。改写条件为（以$l_0$为例）
    \[\begin{split}
      l_0(x) &= \alpha(x-x_1)\cdots(x-x_n) \\
      l_0(x_0) &= 1
    \end{split}\]
    解得
    \[
      \alpha = \frac{1}{(x_0-x_1)\cdots(x_0-x_n)}\quad\blacksquare
    \]
  \remark
    这样构造插值多项式的动机在于在取定插值节点后，插值实际上相当于
    构造一个从$\mbf{y}=(y_0,\,\dots,\,y_n)\in\R^{n+1}$
    到$y^*(x)\in P_n$的一个映射$\ms{F}$，并且可以证明，
    $\ms{F}$是线性的。因此成立
    \[
      \ms{F}(\mbf{y}) = \ms{F}(\sum_{i=0}^ny_i\mbf{e}_i)
       = \sum_{i=0}^ny_i\ms{F}(\mbf{e}_i)
       = \sum_{i=0}^ny_i l_i(x).
    \]

  \begin{thm}[Lagrange余项公式]
    设符号含义同\thmref{thm: Lagrange插值法}且$\f$充分光滑，则
    对于每一个固定的$x$成立
    \[
      \f(x) - (L_n\f)(x) =
      \frac{\f^{(n+1)}(\xi)}{(n+1)!}\omega_{n+1}(x)
    \]
    其中$\xi\in(a, b)$且
    \[
      \omega_{n+1}(x) = (x-x_0)\cdots(x-x_n).
    \]
  \end{thm}
  \proof
    固定$x\ne x_i$，定义$R(x)$满足
    \[
      \f(x) - (L_n\f)(x) = R(x)\omega_{n+1}(x).
    \]
    构造辅助函数$\g(t)$
    \[
      \g(t) = \f(t) - (L_n\f)(t) - R(x)\omega_{n+1}(t).
    \]
    根据插值法与$R(x)$的定义，成立
    \[
      \g(x_i) = 0,\quad g(x) = 0,
    \]
    即函数$\g(t)$有$n+2$个零点。反复应用Rolle定理，可知存在
    $\xi\in(a, b)$，成立$\g^{(n+1)} = 0$，即
    \[\begin{split}
      & \g^{(n+1)}(\xi) = \f^{(n+1)}(\xi) - R(x)(n+1)! = 0 \\
      \Rightarrow\quad& R(x) = \frac{\f^{(n+1)}(\xi)}{(n+1)!}
    \end{split}\]
    结合$R(x)$的定义式即可知命题成立。$\blacksquare$
  \remark
    当已知$\f^{(n+1)}$有界时，可以使用此公式进行估计。

\subsection{Runge现象}
  \begin{thm}
    对于复函数$\f(z)$，如果存在$r_0>\frac32(b-a)$，使得
    $\f(z)$在$B_{r_0}(\frac{a+b}{2})$内解析，则
    $P_n(x) = L_n(x)$在$[a, b]$上一致收敛与$\f(z)$.
    这里$B_{r_0}(\frac{a+b}{2})$为以$\frac{a+b}{2}$为圆心，
    $r_0$为半径的圆。
  \end{thm}


\newpage
\section{附录}
\subsection{不等式}

  \begin{lemma}[排序不等式]
    \label{lemma: 排序不等式}
    对于满足下述条件的$\{a_n\}$，$\{b_n\}$，
    \[\begin{split}
      & 0 \le a_1\le a_2\le\cdots\le a_n \\
      & 0 \le b_1\le b_2\le\cdots\le b_n
    \end{split}\]
    则同序相乘求和值最大，逆序最小，即
    \[
      \sum_{i=1}^n a_ib_i \ge \sum_{i=1}^n a_ib_{k_i}
      \ge \sum_{i=1}^n a_ib_{n-i+1}
    \]
  \end{lemma}

  \begin{lemma}[算数-几何均值不等式]
    \[
      (a_1a_2\cdots a_n)^{1/n} \le \frac{a_1+a_2+\cdots+a_n}{n}
    \]
    当且仅当$a_1 = a_2 = \cdots = a_n$时等号成立。
  \end{lemma}
  \proof
    因为有齐次性，所以不妨设$\prod a_i=1$，并令
    \[
      a_1=\frac{\alpha_1}{\alpha_2},\quad
      \dots,\quad
      a_{n-1} = \frac{\alpha_{n-1}}{\alpha_n},\quad
      a_n = \frac{\alpha_n}{\alpha_1}
    \]
    则只需证明下式即可。
    \[
      \frac{\alpha_1}{\alpha_2} + \cdots + \frac{\alpha_n}{\alpha_1}
      \ge n
    \]
    不妨设$\alpha_1 \le \alpha_2 \le \cdots \le \alpha_n$，则根据排序不等式
    \[
      \lhs \ge \alpha_1\frac{1}{\alpha_1} + \cdots + \alpha_n\frac{1}{\alpha_n}
       = n \quad\blacksquare
    \]

\end{document}
